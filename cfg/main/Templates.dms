container Templates: Using = "Units;geometries;Classifications"
{      
	#include <netwerk.dms>
	
	Template CreateNetwork_T
	{
		// begin case parameters
		unit<uint32> OrgDomain;
		unit<uint32> DestDomain;
		unit<uint32> RoadDomain;
		parameter<string> TransportType;
		// end case parameters

		attribute<rdc>                      OrgLocations  (OrgDomain)      := orgDomain/geometry;
		attribute<rdc>                      destLocations (DestDomain)     := destDomain/geometry;
		
		unit<uint32> Locations := union_unit(orgDomain, destDomain)
		{
			attribute<rdc>                  geometry                       := union_data(.,orgLocations, destLocations);
			attribute<bool>                            IsOrg                          := union_data(.,const(TRUE , OrgDomain), const(FALSE,DestDomain));
			attribute<bool>                            IsDest                         := union_data(.,const(FALSE, OrgDomain), const(TRUE ,DestDomain));
		}
		unit<uint32> UniqueLocations    := unique(Locations/geometry) 
		, DialogType = "map", DialogData = "values"
		{ 
			attribute<NodeSet>   Node_rel      := rlookup(values, NodeSet/values); 
			attribute<Locations> Locations_rel := rlookup(values, Locations/geometry);
			attribute<bool>      IsOrg         := rjoin(values, Locations/geometry, Locations/IsOrg);
		}
		
		unit<uint32> RoadsWithLocations := connect(roadDomain/geometry, UniqueLocations/values)
		{ 
			attribute<rdc>                             geometry (arc)                  := uniondata; 
			attribute<km_hr>                           max_speed                       := ='MakeDefined(RoadDomain/freeflow_speed_'+TransportType+'[arc_rel], ModelParameters/Advanced/'+TransportType+'DefaultSpeed)';  
			attribute<km_hr>                           congested_speed                 := ='MakeDefined(RoadDomain/congestion_speed_'+TransportType+'[arc_rel], ModelParameters/Advanced/'+TransportType+'DefaultSpeed)';  
		}

		unit<uint32> LinkSet := arc2segm(RoadsWithLocations/geometry)
		, Descr = "The original link set"
		{
			attribute<NodeSet>                         F1                             := rlookup(point, NodeSet/Values);
			attribute<NodeSet>                         F2                             := rlookup(nextpoint, NodeSet/Values);
			attribute<km_hr>                           Max_Speed                      := RoadsWithLocations/Max_Speed[SequenceNr];
			attribute<km_hr>                           Congested_Speed                := RoadsWithLocations/Congested_Speed[SequenceNr];
			attribute<s_f>                             Impedance_freeflow             := (arc_length(geometry, m) == 0[m] ? 0.01[m] : arc_length(geometry, m)) / (Max_Speed / 3600[s_f / hr_f] * 1000[m / km]);
			attribute<s_f>                             Impedance_congested            := (arc_length(geometry, m) == 0[m] ? 0.01[m] : arc_length(geometry, m)) / (Congested_Speed / 3600[s_f / hr_f] * 1000[m / km]);
			
			attribute<bool>                            IsPartOfJunctionFreeSection    :=   F1 -> WillBeDeleted || F2 -> WillBeDeleted;
			attribute<bool>                            IsInsideJunctionFreeSection    :=   F1 -> WillBeDeleted && F2 -> WillBeDeleted; 
			attribute<bool>                            IsNotInsideJunctionFreeSection := IsPartOfJunctionFreeSection && !IsInsideJunctionFreeSection; // IsConnectorLink
			attribute<bool>                            IsFinalLink                    := !(F1 -> WillBeDeleted || F2 -> WillBeDeleted);
			
			//For visualisation
			attribute<rdc>                             geometry (arc)                 := points2sequence(PointSet/Point, PointSet/SeqNr, PointSet/Ordinal);
			unit<uint32> PointSet := union_unit(.,.)
			{
				attribute<rdc>                         Point   := Union_Data(., ../Point, ../NextPoint);
				attribute<..>                          SeqNr   := value(id(.) % nrofrows(..), ..);
				attribute<uint32>                      Ordinal := id(.) / nrofrows(..);
			}
		}
		
		unit<uint32> NodeSet  := unique(Linkset/PointSet/Point)
		, Descr = "The original node set"
		{
			attribute<uint32>                          NrConnectedLinks               := pcount(LinkSet/F1) + pcount(LinkSet/F2);
			attribute<bool>                            WillBeDeleted                  := NrConnectedLinks == 2 && pcount(UniqueLocations/Node_rel) == 0;

			//Forward relations
			attribute<JunctionFreeSection>             JunctionFreeSection_rel        := ConnectedParts_rel -> JunctionFreeSection_rel;
			attribute<FinalNodeSet>                    FinalNodeSet_rel               := invert(FinalNodeSet/org_rel); // todo: sneller, mbv sequentiele select_data variant toe te voegen aan GeoDMS
			
			//For visualisation
			attribute<rdc>                             geometry                       := values;
			attribute<ConnectedParts>                  ConnectedParts_rel             := ConnectedParts/PartNr;
		}

		unit<uint32> LinksInsideJunctionFreeSection := select_with_org_rel(LinkSet/IsInsideJunctionFreeSection)
		, Descr = "Those links that are in the junction free section"
		{
			attribute<s_f>                             Impedance_freeflow             := org_rel -> Impedance_freeflow;
			attribute<s_f>                             Impedance_congested            := org_rel -> Impedance_congested;
			attribute<NodeSet>                         F1                             := org_rel -> F1;
			attribute<NodeSet>                         F2                             := org_rel -> F2; 
			attribute<JunctionFreeSection>             JunctionFreeSection_rel        := F1->JunctionFreeSection_rel;
			
			//For visualisation
			attribute<rdc>                             geometry  (arc)                := org_rel -> geometry;
		}
		
		unit<uint32> ConnectedParts := connected_parts(LinksInsideJunctionFreeSection/F1, LinksInsideJunctionFreeSection/F2)
		{
			attribute<NodeSet>                         FirstNode_rel                   := invert(PartNr);
			attribute<bool>                            IsJunctionFreeSection           := FirstNode_rel -> WillBeDeleted;
			attribute<JunctionFreeSection>             JunctionFreeSection_rel         := invert(JunctionFreeSection/org_rel);
		}
		
		unit<uint32> JunctionFreeSection := select_with_org_rel(ConnectedParts/IsJunctionFreeSection)
		, Descr = "Those nodes that are redundant, because there are no junctions on the links"
		{
			attribute<ConnectorLink>                   First_ConnectorLink_rel        := min(id(ConnectorLink), ConnectorLink/JunctionFreeSection_rel); //todo sneller
			attribute<ConnectorLink>                   Last_ConnectorLink_rel         := max(id(ConnectorLink), ConnectorLink/JunctionFreeSection_rel); //todo sneller
			
			attribute<s_f>                             Aggregated_Impedence_freeflow           := sum(LinksInsideJunctionFreeSection/impedance_freeflow, LinksInsideJunctionFreeSection/JunctionFreeSection_rel);
			attribute<s_f>                             First_ConnectorLink_Impedance_freeflow  := First_ConnectorLink_rel -> impedance_freeflow;
			attribute<s_f>                             Last_ConnectorLink_Impedance_freeflow   := Last_ConnectorLink_rel -> impedance_freeflow;
			attribute<s_f>                             Total_Impedance_freeflow                := Aggregated_Impedence_freeflow + First_ConnectorLink_Impedance_freeflow + Last_ConnectorLink_Impedance_freeflow;
			
			attribute<s_f>                             Aggregated_Impedence_congested           := sum(LinksInsideJunctionFreeSection/impedance_congested, LinksInsideJunctionFreeSection/JunctionFreeSection_rel);
			attribute<s_f>                             First_ConnectorLink_Impedance_congested  := First_ConnectorLink_rel -> Impedance_congested;
			attribute<s_f>                             Last_ConnectorLink_Impedance_congested   := Last_ConnectorLink_rel -> Impedance_congested;
			attribute<s_f>                             Total_Impedance_congested                := Aggregated_Impedence_congested + First_ConnectorLink_Impedance_congested + Last_ConnectorLink_Impedance_congested;
			
			attribute<FinalNodeSet>                    FN1                            := First_ConnectorLink_rel -> FinalNodeSet_rel;
			attribute<FinalNodeSet>                    FN2                            := Last_ConnectorLink_rel -> FinalNodeSet_rel;  
			
			//For visualisation
			attribute<rdc>                             FirstPoint                     := FN1 -> Geometry;
			attribute<rdc>                             LastPoint                      := FN2 -> Geometry;
			attribute<rdc>                             geometry (arc)                 := points2sequence(PointSet/Point, PointSet/SeqNr, PointSet/Ordinal);
			unit<uint32> PointSet := union_unit(.,.)
			{
				attribute<rdc>                         Point   := Union_Data(., ../FirstPoint, ../LastPoint);
				attribute<..>                          SeqNr   := value(id(.) % nrofrows(..), ..);
				attribute<uint32>                      Ordinal := id(.) / nrofrows(..);
			}
		}
		
		unit<uint32> UnchangedLinkSet := select_with_org_rel(LinkSet/IsFinalLink)
		, Descr = "Those links that can be used without changes, i.e. no nodes need to be removed"
		{
			attribute<FinalNodeSet>                    FN1                            := NodeSet/FinalNodeSet_rel[org_rel -> F1];
			attribute<FinalNodeSet>                    FN2                            := NodeSet/FinalNodeSet_rel[org_rel -> F2];
			attribute<s_f>                             impedance_freeflow             := LinkSet/impedance_freeflow[org_rel];
			attribute<s_f>                             impedance_congested            := LinkSet/impedance_congested[org_rel];
			
			//For visualisation
			attribute<rdc>                             FirstPoint                     := FinalNodeSet/geometry[FN1];
			attribute<rdc>                             LastPoint                      := FinalNodeSet/geometry[FN2];
			attribute<rdc>                             geometry (arc)                 := points2sequence(PointSet/Point, PointSet/SeqNr, PointSet/Ordinal);
			unit<uint32> PointSet := union_unit(.,.)
			{
				attribute<rdc>                         Point   := Union_Data(., ../FirstPoint, ../LastPoint);
				attribute<..>                          SeqNr   := value(id(.) % nrofrows(..), ..);
				attribute<uint32>                      Ordinal := id(.) / nrofrows(..);
			}
		}
		
		unit<uint32> ConnectorLink := select_with_org_rel(LinkSet/IsNotInsideJunctionFreeSection)
		, Descr = "Those links that connect the unchanged links with the junction free links"
		{
			attribute<NodeSet>                         Fa                             := LinkSet/F1[org_rel];
			attribute<NodeSet>                         Fb                             := LinkSet/F2[org_rel]; 
			attribute<NodeSet>                         F1                             := NodeSet/WillBeDeleted[Fa] ? Fb : Fa; // Unchanged Node
			attribute<NodeSet>                         F2                             := NodeSet/WillBeDeleted[Fa] ? Fa : Fb; // Node in JunctionFreeSection
			attribute<JunctionFreeSection>             JunctionFreeSection_rel        := NodeSet/JunctionFreeSection_rel[F2];
			attribute<FinalNodeSet>                    FinalNodeSet_rel               := invert(FinalNodeSet/org_rel)[F1];
			attribute<s_f>                             Impedance_freeflow             := LinkSet/Impedance_freeflow[org_rel];
			attribute<s_f>                             Impedance_congested            := LinkSet/Impedance_congested[org_rel];
		}
		
		
		unit<uint32> FinalNodeSet := select_with_org_rel(!Nodeset/Willbedeleted)
		, Descr = "The final node set"
		{
			//For visualisation
			attribute<rdc>                             geometry                       := NodeSet/geometry[org_rel];
			attribute<uint32>                          NrConnectedLinks               := pcount(FinalLinkSet/F1) + pcount(FinalLinkSet/F2);
		}
		
		unit<uint32> FinalLinkSet := union_unit(UnchangedLinkSet, JunctionFreeSection)
		, Descr = "The final link set"
		{
			attribute<FinalNodeSet>                    FN1                            := union_data(., UnchangedLinkSet/FN1, JunctionFreeSection/FN1);
			attribute<FinalNodeSet>                    FN2                            := union_data(., UnchangedLinkSet/FN2, JunctionFreeSection/FN2);
			attribute<s_f>                             impedance_freeflow             := union_data(., UnchangedLinkSet/impedance_freeflow, JunctionFreeSection/Total_Impedance_freeflow);
			attribute<s_f>                             impedance_augmented_freeflow   := impedance_freeflow + CorrectImpedanceForCrossroads/impedance_Start[s_f] + CorrectImpedanceForCrossroads/impedance_End[s_f];
			attribute<s_f>                             impedance_congested            := union_data(., UnchangedLinkSet/impedance_congested, JunctionFreeSection/Total_Impedance_congested);
			attribute<s_f>                             impedance_augmented_congested  := impedance_congested + CorrectImpedanceForCrossroads/impedance_Start[s_f] + CorrectImpedanceForCrossroads/impedance_End[s_f];
			attribute<FinalNodeSet>                    F1                             := FN1;
			attribute<FinalNodeSet>                    F2                             := FN2;
			attribute<FinalNodeSet>                    OrgNode_rel  (OrgDomain)       := rlookup(orgLocations, FinalNodeSet/geometry);
			attribute<FinalNodeSet>                    DestNode_rel (DestDomain)      := rlookup(destLocations, FinalNodeSet/geometry);

			//For visualisation
			attribute<rdc>                             FirstPoint                     := FinalNodeSet/geometry[FN1];
			attribute<rdc>                             LastPoint                      := FinalNodeSet/geometry[FN2];
			parameter<int16>                           PenWidth                       := 3s, DialogType = "PenWidth";
			attribute<rdc>                             geometry (arc)                 := points2sequence(PointSet/Point, PointSet/SeqNr, PointSet/Ordinal);
			unit<uint32> PointSet := union_unit(.,.)
			{
				attribute<rdc>                         Point   := Union_Data(., ../FirstPoint, ../LastPoint);
				attribute<..>                          SeqNr   := value(id(.) % nrofrows(..), ..);
				attribute<uint32>                      Ordinal := id(.) / nrofrows(..);
			}
			
			
			container CorrectImpedanceForCrossroads
			// hiermee wordt voor ieder begin en eind node het aantal geconnecte links bepaald
			// dit bepaalt of het een bocht (2 links), zijweg (3 links), kruising (4 links) of complexe kruising (meer dan 4 links) is
			// afhankelijk van dit aantal wordt een aantal seconden opgeteld bij de totale impedance
			{
				// helft van de opgegeven waarden omdat er zowel bij begin als einde een factor wordt opgeteld
				parameter<s>       Impedance2Links    := 0[s];
				parameter<s>       Impedance3Links    := 2[s];
				parameter<s>       Impedance4Links    := 5[s];
				parameter<s>       Impedance_gt4Links := 6[s];

				attribute<uint32>  Start(FinalLinkSet)     := FinalNodeSet/NrConnectedLinks[FinalLinkSet/F1];
				attribute<uint32>  End  (FinalLinkSet)     := FinalNodeSet/NrConnectedLinks[FinalLinkSet/F2];
			
				attribute<s> impedance_Start (FinalLinkSet):=
					switch(
						 case(Start <= 2, Impedance2Links)
						,case(Start  = 3, Impedance3Links)
						,case(Start  = 4, Impedance4Links)
						,Impedance_gt4Links
					);
			
				attribute<s> impedance_End (FinalLinkSet):=
					switch(
						 case(End <= 2, Impedance2Links)
						,case(End  = 3, Impedance3Links)
						,case(End  = 4, Impedance4Links)
						,Impedance_gt4Links
					);
			}
		}
	}
	
	Template createNetwork : using = "geometries"
	{
		unit<uint32>      inStart;
		unit<uint32>      inEind;
		unit<uint32>      Roads;
		parameter<string> TravelMode;
		parameter<string> Direction;
		////
		parameter<min_f> MaxDistSelectie_min := ='ModelParameters/Max'+TravelMode+'Time_'+Direction;
		parameter<s_f>   MaxDistSelectie_sec := convert(MaxDistSelectie_min, s_f);
		
		unit<uint32> points := TiledUnit(25000[union_unit(inStart, inEind)])
		{
			attribute<rdc>    geometry               := union_data(., inStart/geometry, inEind/geometry);
			attribute<string> Name                   := union_data(., inStart/name , inEind/name);
		}
		
		unit<uint32> Lines := Roads
		{
			attribute<rdc>        geometry (arc) := Roads/geometry;
			attribute<float32>    length         := arc_length(geometry, m);
			parameter<string>     speed_str      := ModelParameters/UseActualBikeSpeeds && TravelMode == 'Biking'
														? 'Roads/congestion_speed_bike '
														: ModelParameters/UseActualBikeSpeeds && TravelMode == 'Walking'
															? 'const(ModelParameters/Advanced/WalkingSpeed_kmhr,.)'
															: !ModelParameters/UseActualBikeSpeeds && TravelMode == 'Biking'
																? 'const(ModelParameters/Advanced/BikingSpeed_kmhr,.)'
																: !ModelParameters/UseActualBikeSpeeds && TravelMode == 'Walking'
																	? 'const(ModelParameters/Advanced/WalkingSpeed_kmhr,.)'
																	: 'const(ModelParameters/Advanced/WalkingSpeed_kmhr,.)';
			attribute<km_hr>      speed          := =speed_str;
		}
		
		unit<uint32> Network := connect(Lines/geometry, points/geometry)
		{
			attribute<rdc>      geometry (arc)      := UnionData;
			attribute<rdc>      fromPoint           := first_point(geometry);
			attribute<rdc>      toPoint             := last_point(geometry);
			attribute<km_hr>    speed               := Lines/speed[arc_rel];
			attribute<m_s>      speed_ms            := convert(speed, m_s);
			attribute<m>        Length              := arc_length(geometry, m);
			attribute<s_f>      Seconds             := MakeDefined(Length / speed_ms, 1[s_f]);
			attribute<s_f>      Duration            := Seconds;
			// attribute<s_f>      Duration            := MakeDefined(Length / speed_ms, 1[s_f]);
			unit<uint32>        PointSet            := union_unit(Network, Network)
			{
				attribute<rdc>  points              := union_data(.,fromPoint,toPoint);
			}
			
			unit<uint32>        NodeSet             := unique(PointSet/points);
			
			attribute<NodeSet>  F1                  := rlookup(fromPoint,NodeSet/Values);
			attribute<NodeSet>  F2                  := rlookup(toPoint,NodeSet/Values);
			
			attribute<NodeSet>  org_node (inStart)  := rlookup(inStart/geometry, NodeSet/Values);
			attribute<NodeSet>  dst_node (inEind)   := rlookup(inEind/geometry, NodeSet/Values);
			
			unit<uint32> NetCheck := connected_parts(F1, F2);
			
			unit<uint32> ODMatrix :=
				impedance_matrix('bidirectional;startPoint(Node_rel):max_imp;endPoint(Node_rel);cut(OrgZone_max_imp);limit(OrgZone_max_mass,DstZone_mass);alternative(link_imp):alt_imp;od:impedance,OrgZone_rel,DstZone_rel'
					, Seconds
					, F1
					, F2
					, org_node
					, dst_node
					, MaxDistSelectie_sec //cut impedance      
					, ModelParameters/MaxODconn, 1f //limit
					, Length //alt imp
				)
			{
				attribute<Time>	   Duration                         := RoundUp(Impedance)[uint32][Time];
				attribute<float32> Duration_minutes                 := Impedance / 60f;
				attribute<inStart> StartRef                         := OrgZone_rel; 
				attribute<inEind>  EindRef                          := DstZone_rel; 
				attribute<string>  StartName                        := inStart/name[StartRef];
				attribute<string>  EindName                         := inEind/name[EindRef];
				attribute<m>       Distance                         := float32(alt_imp)[m]; 
				attribute<rdc>     Start_point                      := inStart/geometry[StartRef];
				attribute<rdc>     Eind_point                       := inEind/geometry[EindRef];
				attribute<Complete_Stops_Domain> Complete_Stops_rel := inEind/Stops_rel[EindRef]; 
				attribute<rdc>     geometry (arc)                   := points2sequence(LinkPoints/geometry, LinkPoints/ODPathRel, LinkPoints/CumulOrdinal);
				attribute<string>  Label                            := TravelMode+' path from: ' + StartName + ' to ' + EindName;

				unit<uint32> LinkPoints := union_unit(., .)
				{
					attribute<..>                   ODPathRel    := union_data(., id(..), id(..));
					attribute<rdc>                  geometry     := union_data(., ../Start_point, ../Eind_point);
					attribute<uint32>               CumulOrdinal := union_data(., const(0,..,uint32), const(1,..,uint32));
				}
				
				unit<uint32> Complete_Stops_Domain := SourceData/Infrastructuur/GTFS/StudyAreaFeeds/Stops;
			}
		}
	}

	Template PrivateTransport_Car_T
	{
		unit<uint32> org;
		unit<uint32> dest;
		parameter<bool>    DoMakeAllPairs;
		parameter<string>  CongestionType;
		///
		parameter<string>  netwerk_type_OSM := 'car';
		
		container Settings
		{
			parameter<string>  netwerk_type_Logit := netwerk_type_OSM == classifications/OSM/netwerk_type/name[classifications/OSM/netwerk_type/V/Pedestrian] ? classifications/OSM/netwerk_type/name[classifications/OSM/netwerk_type/V/Bike] : netwerk_type_OSM;
			
			parameter<min_f>   max_traveldistance_min  := ModelParameters/MaxCarTime;
			parameter<uint32>  nr_balancing_iter       := ModelParameters/Advanced/PrivateTransportSettings/nr_balancing_iter;
			parameter<uint32>  nr_imp_iter             := ModelParameters/Advanced/PrivateTransportSettings/nr_imp_iter;
			parameter<float32> imp_margin              := ModelParameters/Advanced/PrivateTransportSettings/imp_margin;
			parameter<float32> imp_step                := ModelParameters/Advanced/PrivateTransportSettings/imp_step; 
			
			attribute<uint32> dest_mass (dest) := ='dest/'+ModelParameters/items_of_interest;
			
			parameter<string> fileNamePrefix :=  ModelParameters/Advanced/fileNamePrefix;
			parameter<string> fileNameSuffix :=  
				'_ORG-'    + ModelParameters/Orgset + '-' + regio_name + 
				'_DEST-'   + ModelParameters/Advanced/DestSet_string +
				'_NETWERK-'+ netwerk_type_OSM +
				'_DayGroup-'+ModelParameters/CongestionSpeed_DaygroupSelection +
				'_MaxTime-' + string(ModelParameters/MaxCarTime)+'min';

				
			parameter<string> fileNameSuffix_MakeCongestionSpeeds :=  
				'_ORG-'+Determine_CongestedSpeeds/InwonerOD_set+
				'_DEST-'+Determine_CongestedSpeeds/InwonerOD_set+
				'_OSMdate-' + ModelParameters/OSM_file_date+
				'_NDWdates-' + ModelParameters/Advanced/NDW_meetmomenten/DateRange+
				'_DayGroup-'+ModelParameters/CongestionSpeed_DaygroupSelection;
			parameter<string> fileNameSuffix_ReadCongestionSpeeds :=  
				'_ORG-'+Determine_CongestedSpeeds/InwonerOD_set+
				'_DEST-'+Determine_CongestedSpeeds/InwonerOD_set+
				'_OSMdate-' + ModelParameters/CarCongestionSpeed_date+
				'_NDWdates-' + ModelParameters/Advanced/NDW_meetmomenten/DateRange+
				'_DayGroup-'+ModelParameters/CongestionSpeed_DaygroupSelection;  
				
			parameter<string> logit_weight_prefix := 'ModelParameters/Advanced/Distance_Decay/' + netwerk_type_Logit;
			parameter<string> logit_weights_expr  := logit_weight_prefix+'_a, ' + logit_weight_prefix+'_b, ' + logit_weight_prefix+'_c';
		}
		
		Container Determine_CongestedSpeeds
		{
			parameter<string> InwonerOD_set := 'Gemeenten'; // Wijk_y2020
			
			parameter<string> Org_domain_str        := replace(rjoin(lowercase(InwonerOD_set), lowercase(ModelParameters/Advanced/org_domain_list/label), ModelParameters/Advanced/org_domain_list/path), '@REGIO@', regio_name);

			unit<uint32> org  := =Org_domain_str;
			unit<uint32> dest := org;
				
			container NetwerkSpec :=
				Templates/CreateNetwork_T(
					  org
					, dest
					, SourceData/Infrastructuur/OSM/Network_Car/isVerbonden
					, CongestionType //Pedestrian Bike MorningRush NoonRush LateEveningRush
				);
				
			attribute<Float32> dest_mass  (dest) := dest/nr_inwoners[float32];
			attribute<Float32> org_mass   (org)  := org/nr_inwoners[float32];
			
			unit<uint32> LinkSet := NetwerkSpec/FinalLinkSet 
			{
				attribute<bool> isBidirectional := 
					wegtype != classifications/OSM/wegtype/V/motorway  
					&& wegtype != classifications/OSM/wegtype/V/motorway_link; // motor way en motor way link, snelwegen zijn niet bidirectional
					
				attribute<min_f> impedance_min_max_car         := NetwerkSpec/FinalLinkSet/impedance_max_car  / 60[s_f / min_f];
				attribute<min_f> impedance_min_max_limit_car   := NetwerkSpec/FinalLinkSet/impedance_max_limit_car  / 60[s_f / min_f];
				attribute<min_f> impedance_min_MorningRush     := NetwerkSpec/FinalLinkSet/impedance_MorningRush / 60[s_f / min_f];
				attribute<min_f> impedance_min_NoonRush        := NetwerkSpec/FinalLinkSet/impedance_NoonRush   / 60[s_f / min_f];
				attribute<min_f> impedance_min_LateEveningRush := NetwerkSpec/FinalLinkSet/impedance_LateEveningRush   / 60[s_f / min_f];
				
				attribute<km>                           lengte                      := convert(arc_length(segments, m), km);
				
				attribute<km_hr>                        Speed_max                   :=  lengte / convert(impedance_min_max_car, hr_f);
				attribute<km_hr>                        Speed_max_limit             :=  lengte / convert(impedance_min_max_limit_car, hr_f);
				attribute<km_hr>                        Speed_congested_morning     :=  lengte / convert(impedance_min_MorningRush, hr_f);
				attribute<km_hr>                        Speed_congested_noon        :=  lengte / convert(impedance_min_NoonRush, hr_f);
				attribute<km_hr>                        Speed_congested_late        :=  lengte / convert(impedance_min_LateEveningRush, hr_f);
				
			}


			container freeflow_linkusage      := freeflow_linkusage_T(LinkSet, Dest, LinkSet/impedance_min_max_car);
			container CALC_OD_MorningRush     := linkflow_congested(LinkSet, LinkSet/impedance_min_MorningRush, 'MorningRush');
			container CALC_OD_NoonRush        := linkflow_congested(LinkSet, LinkSet/impedance_min_NoonRush,'NoonRush');
			container CALC_OD_LateEveningRush := linkflow_congested(LinkSet, LinkSet/impedance_min_LateEveningRush, 'LateEveningRush');
			
			
			unit<uint32> Make_CongestionSpeeds_FSS := LinkSet
			, StorageName = "='%ProjDir%/UnlinkedData/CongestionSpeeds'+Settings/fileNameSuffix_MakeCongestionSpeeds+'.fss'"
			{ 
				attribute<geometries/rdc>               segments (arc)                      := LinkSet/segments;
				attribute<classifications/OSM/wegtype>  wegtype                             := LinkSet/wegtype;
				attribute<min_f>                        MorningRush_imp_simulated           := CALC_OD_MorningRush/Impedance_congested;
				attribute<min_f>                        NoonRush_imp_simulated              := CALC_OD_NoonRush/Impedance_congested;
				attribute<min_f>                        LateEveningRush_imp_simulated       := CALC_OD_LateEveningRush/Impedance_congested;
				attribute<min_f>                        MaxSpeed_imp                        := LinkSet/impedance_min_max_car;
				attribute<min_f>                        MaxSpeed_limit_imp                  := LinkSet/impedance_min_max_limit_Car;

				attribute<min_f>                        MorningRush_imp_observed            := LinkSet/impedance_min_MorningRush;
				attribute<min_f>                        NoonRush_imp_observed               := LinkSet/impedance_min_NoonRush;
				attribute<min_f>                        LateEveningRush_imp_observed        := LinkSet/impedance_min_LateEveningRush;

				attribute<float32>                      MorningRush_flow_simulated          := CALC_OD_MorningRush/Flow_congested;
				attribute<float32>                      NoonRush_flow_simulated             := CALC_OD_NoonRush/Flow_congested;
				attribute<float32>                      LateEveningRush_flow_simulated      := CALC_OD_LateEveningRush/Flow_congested;
				
				attribute<float32>                      MorningRush_flow_observed           := NetwerkSpec/OrgToDest/LinkSet/MorningRush_flow;
				attribute<float32>                      NoonRush_flow_observed              := NetwerkSpec/OrgToDest/LinkSet/NoonRush_flow;
				attribute<float32>                      LateEveningRush_flow_observed       := NetwerkSpec/OrgToDest/LinkSet/LateEveningRush_flow;
			}
			
			unit<uint32> Read_CongestionSpeeds_FSS
			: StorageName = "='%ProjDir%/UnlinkedData/CongestionSpeeds'+Settings/fileNameSuffix_ReadCongestionSpeeds+'.fss'"
			, StorageReadOnly = "true"
			, DialogType = "map", DialogData = "segments"
			{
				attribute<geometries/rdc>               segments (arc);
				attribute<classifications/OSM/wegtype>  wegtype;
				
				attribute<km>                           lengte                      := convert(arc_length(segments, m), km);
				
				attribute<km_hr>                        Speed_max                   :=  lengte / convert(MaxSpeed_imp, hr_f);
				attribute<km_hr>                        Speed_max_limit             :=  lengte / convert(MaxSpeed_limit_imp, hr_f);
				attribute<km_hr>                        Speed_congested_morning     :=  lengte / convert(MorningRush_imp_simulated, hr_f);
				attribute<km_hr>                        Speed_congested_noon        :=  lengte / convert(NoonRush_imp_simulated, hr_f);
				attribute<km_hr>                        Speed_congested_late        :=  lengte / convert(LateEveningRush_imp_simulated, hr_f);
				
				attribute<float32>                      MorningRush_flow_observed;
				attribute<float32>                      NoonRush_flow_observed;
				attribute<float32>                      LateEveningRush_flow_observed;

				attribute<min_f>                        MorningRush_imp_observed;
				attribute<min_f>                        NoonRush_imp_observed;
				attribute<min_f>                        LateEveningRush_imp_observed;
				
				attribute<float32>                      MorningRush_flow_simulated;
				attribute<float32>                      NoonRush_flow_simulated;
				attribute<float32>                      LateEveningRush_flow_simulated;
				
				attribute<min_f>                        MorningRush_imp_simulated;
				attribute<min_f>                        NoonRush_imp_simulated;
				attribute<min_f>                        LateEveningRush_imp_simulated;
				attribute<min_f>                        MaxSpeed_imp;
				attribute<min_f>                        MaxSpeed_limit_imp;
				
				parameter<min_f>                        gewogen_observed_imp_morning         := sum(MorningRush_imp_observed * MorningRush_flow_observed) / sum(MorningRush_flow_observed);
				parameter<min_f>                        gewogen_observed_imp_noon            := sum(NoonRush_imp_observed * NoonRush_flow_observed) / sum(NoonRush_flow_observed);
				parameter<min_f>                        gewogen_observed_imp_late            := sum(LateEveningRush_imp_observed * LateEveningRush_flow_observed) / sum(LateEveningRush_flow_observed);
				
				parameter<min_f>                        gewogen_sim_imp_morning              := sum(MorningRush_imp_simulated * MorningRush_flow_simulated) / sum(MorningRush_flow_simulated);
				parameter<min_f>                        gewogen_sim_imp_noon                 := sum(NoonRush_imp_simulated * NoonRush_flow_simulated) / sum(NoonRush_flow_simulated);
				parameter<min_f>                        gewogen_sim_imp_late                 := sum(LateEveningRush_imp_simulated * LateEveningRush_flow_simulated) / sum(LateEveningRush_flow_simulated);
				
				container Connectiveness
				{
					unit<uint32> src := ..;
					attribute<geometries/rdc>               point (src)           := first_point(src/segments);
					attribute<geometries/rdc>               nextpoint (src)       := last_point(src/segments);
					
					unit<uint32> pointset : = union_unit(src,src)
					{
						attribute<geometries/rdc>       point       := union_data(., ../point, ../nextpoint);
						attribute<bool>                 isVerbonden := isNull(rlookup(point, NodesNotConnected/point));
						attribute<src>                  ArcNr       := value(ID(.) % #(src), src);
					}
					
					unit<uint32> NodeSet := unique(pointset/point)
					,	DialogData = "Values"
					,	DialogType = "Map"
					{
						attribute<geometries/rdc> values;
					}

					attribute<NodeSet> F1 (src) := rlookup(point,     NodeSet/Values);
					attribute<NodeSet> F2 (src) := rlookup(nextpoint, NodeSet/Values);
				
					unit<uint32> networks:= connected_parts(F1, F2) // Verzameling van alle netwerken, inclusief de subnetwerken.
					{
						attribute<uint32>   nr_nodes   := sum(const(1, NodeSet, uint32), partnr);
						parameter<uint32>   MaxNrNodes := max(networks/nr_nodes);
						parameter<networks> main       := rlookup(MaxNrNodes, nr_nodes); // uitgangspunt: het netwerk met de meeste nodes is het relevante netwerk
					}

					unit<uint32> NodesNotConnected := Subset(networks/partnr <> networks/main)
					{
						attribute<geometries/rdc> point := NodeSet/Values[Nr_OrgEntity];
					}
					attribute<bool> isVerbonden (src) := all(pointset/isVerbonden, pointset/ArcNr);
				}
			}
		}
		
		
		Template freeflow_linkusage_T
		{
			unit<uint32> LinkSet;
			unit<uint32> Dest;
			attribute<min_f> impedance_min   (LinkSet);
			///
			
			unit<uint32> balancing_iter := range(uint32, 0, settings/nr_balancing_iter) 
			{
				attribute<string> Name   := 'I'+string(ID(.));
				attribute<string> products := // choose from D_i,M_ix,C_j,M_xj,Link_flow
					(ID(.)==first(ID(.))?'D_i,':'') // only genereate D_i in first iteration for usage as fleeflow result.
					+'C_j'
					+(ID(.)==last(ID(.))?',Link_flow':''); // only genereate cumulate link_flow in last iteration to save space&time
			}
			
			container balancing_iters:= 
				for_each_nex(
					balancing_iter/Name
					,'dijkstra_m64('+
						Quote(
							'bidirectional(link_flag);startPoint(Node_rel);endPoint(Node_rel)'
						+	(DoMakeAllPairs ? '' :';cut(OrgZone_max_imp)')
						+	';interaction(v_i,w_j,dist_logit(alpha,beta,gamma)):'+balancing_iter/products
						+	(DoMakeAllPairs ? ';od:impedance,OrgZone_rel,DstZone_rel':'')
						)
					+'	, impedance_min
						, Determine_CongestedSpeeds/NetwerkSpec/OrgToDest/LinkSet/F1
						, Determine_CongestedSpeeds/NetwerkSpec/OrgToDest/LinkSet/F2
						, LinkSet/isBidirectional
						, Determine_CongestedSpeeds/NetwerkSpec/OrgToDest/nr_orgNode
						, Determine_CongestedSpeeds/NetwerkSpec/OrgToDest/nr_destNode'
					+	(DoMakeAllPairs?'':', max_traveldistance_min')
					+	', org_mass' // v_i
						', dest_mass / Cjs/' + balancing_iter/Name + // w_j
						', '+settings/logit_weights_expr+
					')'
					,uint64
				);
				
			container Cjs := 
				for_each_nedv(
					balancing_iter/Name
					,	MakeDefined('median(0.5f, ' + 'balancing_iters/'+balancing_iter/Name[ID(balancing_iter)-1] +'/C_j'+ ', 10.0f)', 'const(1.0f, dest)')
					,	dest
					, float32
				);
		
			container results
			{
				attribute<float32> Flow            (LinkSet) := = 'balancing_iters/'+last(balancing_iter/Name)+'/link_flow';
				attribute<float32> Cj              (dest)    := = 'Cjs/'+last(balancing_iter/Name);
				attribute<float32> NextUnboundedCj (dest)    := = 'balancing_iters/'+last(balancing_iter/Name)+'/C_j'; // added to cheaply analyze stability of found Cj's
			}
		}		
		
		template linkflow_congested
		{		
			unit<uint32> LinkSet;
			attribute<min_f> impedance_observed (LinkSet);
			parameter<string> CongestionPeriod;
			
			attribute<min_f> impedance_min_max_car (LinkSet) := = CongestionPeriod == 'MorningRush' || CongestionPeriod == 'NoonRush' ? 'LinkSet/impedance_min_max_limit_car' : 'LinkSet/impedance_min_max_car';
			
			unit<uint32> impedance_iter := range(uint32, 0, settings/nr_imp_iter) 
			{
				attribute<string> Name   := 'I'+string(ID(.));
				attribute<string> PrevName := Name[ID(impedance_iter)-1];
			}
			container impedance_factors := //margin is check window    //step is de aanpassing
				for_each_nedv(
					impedance_iter/Name
					,MakeDefined(
						// replace('(routings/@PI/link_flow > freeflow_linkusage/results/Flow * settings/imp_margin && LinkSet/isBidirectional ? settings/imp_step : 1.0f) * @PI', '@PI', impedance_iter/PrevName)  //Oude rekenregel
						replace(
							'((routings/@PI/link_flow > freeflow_linkusage/results/Flow * settings/imp_margin) && LinkSet/isBidirectional
								? min_elem(routings/@PI/link_flow / (freeflow_linkusage/results/Flow * settings/imp_margin), settings/imp_step)
								: 1.0f)
								* @PI'
							, '@PI', impedance_iter/PrevName
						)
						,'const(1.0f, LinkSet)'
					)
					,LinkSet
					,float32
				);
			
			container impedances := 
				for_each_nedv(
					impedance_iter/Name
					, 'MakeDefined(impedance_observed, impedance_min_max_car * impedance_factors/'+impedance_iter/Name+')'
					, LinkSet
					, min_f
				);
				
			container impedance_check := 
				for_each_nedv(
					impedance_iter/Name
					, 'impedance_min_max_car <= impedances/'+impedance_iter/Name
					, LinkSet
					, bool
				);
			
			container routings := 
				for_each_nex(
					impedance_iter/Name
					,'dijkstra_m64('+Quote('bidirectional(link_flag);startPoint(Node_rel);endPoint(Node_rel);cut(OrgZone_max_imp);interaction(v_i,w_j,dist_logit(alpha,beta,gamma)):Link_flow')+'
						, impedances/'+impedance_iter/Name+'
						, Determine_CongestedSpeeds/NetwerkSpec/OrgToDest/LinkSet/F1
						, Determine_CongestedSpeeds/NetwerkSpec/OrgToDest/LinkSet/F2
						, LinkSet/isBidirectional
						, Determine_CongestedSpeeds/NetwerkSpec/OrgToDest/nr_orgNode
						, Determine_CongestedSpeeds/NetwerkSpec/OrgToDest/nr_destNode
						, settings/max_traveldistance_min
						, org_mass
						, dest_mass / freeflow_linkusage/results/Cj 
						, '+settings/logit_weights_expr+'
					)'
					, uint64
				);
			attribute<float32>        Flow_congested      (LinkSet) := ='routings/'+last(impedance_iter/Name)+'/Link_flow'; 
			attribute<min_f>          Impedance_congested (LinkSet) := ='impedances/'+last(impedance_iter/Name); 
		}
		
			
		container OrgToDest: FreeData = "false", using = "geometries"
		{ 
			unit<uint32> roadDomain := Determine_CongestedSpeeds/Read_CongestionSpeeds_FSS;
			unit<uint32> Locations := union_unit(org, dest)
			,	DialogData  = "Values"
			,	DialogType  = "Map"
			{
				attribute<geometries/rdc> Values := union_data(.,org/geometry, dest/geometry),Label = "Unieke Locations origins en destinations";
			}
			unit<uint32> UniqueLocation := unique(Locations/values);

			unit<uint32> RoadsWithLocations := ='connect_eq(roadDomain/segments, roadDomain/Connectiveness/IsVerbonden[uint32], OrgToDest/UniqueLocation/values, const(1,OrgToDest/UniqueLocation))'
			,	DialogData = "UnionData"
			,	DialogType = "Map"
			{
				attribute<geometries/rdc>              UnionData(arc);
				attribute<classifications/OSM/wegtype> wegtype                         := ='MakeDefined(RoadDomain/wegtype[arc_rel], value(69,classifications/OSM/wegtype))';
				attribute<m>                           lengte                          := arc_length(UnionData, m) == 0[m] ? 0.01[m] : arc_length(UnionData, m);
				attribute<min_f>                       impedance_max_car_min           := RoadDomain/MaxSpeed_imp[arc_rel];
				attribute<min_f>                       impedance_max_limit_car_min     := RoadDomain/MaxSpeed_limit_imp[arc_rel];
				attribute<min_f>                       impedance_MorningRush_min       := RoadDomain/MorningRush_imp_simulated[arc_rel];
				attribute<min_f>                       impedance_NoonRush_min          := RoadDomain/NoonRush_imp_simulated[arc_rel];
				attribute<min_f>                       impedance_LateEveningRush_min   := RoadDomain/LateEveningRush_imp_simulated[arc_rel];
			}
					
				
					
			unit <uint32> LinkSet := arc2segm(RoadsWithLocations/UnionData)
			,	DialogData = "segments"
			,	DialogType = "Map"
			{
				attribute<geometries/rdc>               segments (arc)                  := points2sequence(pointset/point, pointset/ArcID, pointset/VolgNr);
				attribute<classifications/OSM/wegtype>  wegtype                         := RoadsWithLocations/wegtype[SequenceNr];
				attribute<m>                            lengte                          := arc_length(segments, m) == 0[m] ? 0.01[m] : arc_length(segments, m);
				
				attribute<bool> isBidirectional := 
					wegtype != classifications/OSM/wegtype/V/motorway  
					&& wegtype != classifications/OSM/wegtype/V/motorway_link; // motor way en motor way link, snelwegen zijn niet bidirectional
					
				
				attribute<min_f>                        impedance_max_car_min           := MakeDefined(RoadsWithLocations/impedance_max_car_min[SequenceNr], convert(lengte / (ModelParameters/Advanced/CarDefaultSpeed_low / 3600[s_f / hr_f] * 1000[m / km]),min_f));
				attribute<min_f>                        impedance_max_limit_car_min     := MakeDefined(RoadsWithLocations/impedance_max_limit_car_min[SequenceNr], convert(lengte / (ModelParameters/Advanced/CarDefaultSpeed_low / 3600[s_f / hr_f] * 1000[m / km]),min_f));
				attribute<min_f>                        impedance_MorningRush_min       := MakeDefined(RoadsWithLocations/impedance_MorningRush_min[SequenceNr], convert(lengte / (ModelParameters/Advanced/CarDefaultSpeed_low / 3600[s_f / hr_f] * 1000[m / km]),min_f));
				attribute<min_f>                        impedance_NoonRush_min          := MakeDefined(RoadsWithLocations/impedance_NoonRush_min[SequenceNr], convert(lengte / (ModelParameters/Advanced/CarDefaultSpeed_low / 3600[s_f / hr_f] * 1000[m / km]),min_f));
				attribute<min_f>                        impedance_LateEveningRush_min   := MakeDefined(RoadsWithLocations/impedance_LateEveningRush_min[SequenceNr], convert(lengte / (ModelParameters/Advanced/CarDefaultSpeed_low / 3600[s_f / hr_f] * 1000[m / km]),min_f));
				
				attribute<NodeSet>                      F1                              := rlookup(point,     NodeSet/Values);
				attribute<NodeSet>                      F2                              := rlookup(nextpoint, NodeSet/Values);
				
				unit<uint32> pointset := Union_Unit(LinkSet, LinkSet)
				{
					attribute<geometries/rdc>   point   := Union_Data(pointset, LinkSet/point, LinkSet/nextpoint);
					attribute<LinkSet>          ArcID   := value(ID(pointset) % nrofrows(LinkSet), LinkSet);
					attribute<uint32>           VolgNr  := ID(pointset) / nrofrows(LinkSet);
				}
				
			}
			
			unit<uint32> NodeSet  := unique(linkset/pointset/point)
			,	DialogData = "Values"
			,	DialogType = "Map";

			attribute<NodeSet> nr_orgNode  (org)   := rlookup(org/geometry, NodeSet/Values);
			attribute<NodeSet> nr_destNode (dest)  := rlookup(dest/geometry, NodeSet/Values);
		}
		
		container Traveltimes
		{
			unit<uint64> MorningRush :=
				dijkstra_m64('bidirectional;startPoint(Node_rel):max_imp;endPoint(Node_rel);cut(OrgZone_max_imp);od:impedance,OrgZone_rel,DstZone_rel'
					, convert(OrgToDest/LinkSet/impedance_MorningRush_min, s_f)
					, OrgToDest/LinkSet/F1
					, OrgToDest/LinkSet/F2
					, OrgToDest/nr_orgNode
					, OrgToDest/nr_destNode
					, convert(settings/max_traveldistance_min, s_f) //cut impedance      
				)
			{
				attribute<string> Org_Dest := string(OrgZone_rel)+'_'+string(DstZone_rel);
			}
			unit<uint64> NoonRush :=
				dijkstra_m64('bidirectional;startPoint(Node_rel):max_imp;endPoint(Node_rel);cut(OrgZone_max_imp);od:impedance,OrgZone_rel,DstZone_rel'
					, convert(OrgToDest/LinkSet/impedance_NoonRush_min, s_f)
					, OrgToDest/LinkSet/F1
					, OrgToDest/LinkSet/F2
					, OrgToDest/nr_orgNode
					, OrgToDest/nr_destNode
					, convert(settings/max_traveldistance_min, s_f) //cut impedance      
				)
			{
				attribute<string> Org_Dest := string(OrgZone_rel)+'_'+string(DstZone_rel);
			}
			unit<uint64> LateEveningRush :=
				dijkstra_m64('bidirectional;startPoint(Node_rel):max_imp;endPoint(Node_rel);cut(OrgZone_max_imp);od:impedance,OrgZone_rel,DstZone_rel'
					, convert(OrgToDest/LinkSet/impedance_LateEveningRush_min, s_f)
					, OrgToDest/LinkSet/F1
					, OrgToDest/LinkSet/F2
					, OrgToDest/nr_orgNode
					, OrgToDest/nr_destNode
					, convert(settings/max_traveldistance_min, s_f) //cut impedance      
				)
			{
				attribute<string> Org_Dest := string(OrgZone_rel)+'_'+string(DstZone_rel);
			}

			unit<uint64> MaxSpeed :=
				dijkstra_m64('bidirectional;startPoint(Node_rel):max_imp;endPoint(Node_rel);cut(OrgZone_max_imp);od:impedance,OrgZone_rel,DstZone_rel'
					, convert(OrgToDest/LinkSet/impedance_max_car_min, s_f)  //impedance_max_car_min of impedance_max_limit_car_min
					, OrgToDest/LinkSet/F1
					, OrgToDest/LinkSet/F2
					, OrgToDest/nr_orgNode
					, OrgToDest/nr_destNode
					, convert(settings/max_traveldistance_min, s_f) //cut impedance      
				)
			{
				attribute<string> Org_Dest := string(OrgZone_rel)+'_'+string(DstZone_rel);
			}
		}
		
		container Decayed
		{
			unit<uint64> MorningRush := 
				dijkstra_m64('bidirectional(link_flag);startPoint(Node_rel);endPoint(Node_rel);cut(OrgZone_max_imp);interaction(v_i,w_j,dist_logit(alpha,beta,gamma)):D_i'
					, convert(OrgToDest/LinkSet/impedance_MorningRush_min, s_f)
					, OrgToDest/LinkSet/F1
					, OrgToDest/LinkSet/F2
					, OrgToDest/LinkSet/isBidirectional
					, OrgToDest/nr_orgNode
					, OrgToDest/nr_destNode
					, convert(settings/max_traveldistance_min, s_f) 
					, 1f                                 // v_i
					, settings/dest_mass[float32]        // w_j
					, ModelParameters/Advanced/Distance_Decay/car_a , ModelParameters/Advanced/Distance_Decay/car_b , ModelParameters/Advanced/Distance_Decay/car_c
				);

			unit<uint64> NoonRush := 
				dijkstra_m64('bidirectional(link_flag);startPoint(Node_rel);endPoint(Node_rel);cut(OrgZone_max_imp);interaction(v_i,w_j,dist_logit(alpha,beta,gamma)):D_i'
					, convert(OrgToDest/LinkSet/impedance_NoonRush_min, s_f)
					, OrgToDest/LinkSet/F1
					, OrgToDest/LinkSet/F2
					, OrgToDest/LinkSet/isBidirectional
					, OrgToDest/nr_orgNode
					, OrgToDest/nr_destNode
					, convert(settings/max_traveldistance_min, s_f) 
					, 1f                                 // v_i
					, settings/dest_mass[float32]        // w_j
					, ModelParameters/Advanced/Distance_Decay/car_a , ModelParameters/Advanced/Distance_Decay/car_b , ModelParameters/Advanced/Distance_Decay/car_c
				);

			unit<uint64> LateEveningRush := 
				dijkstra_m64('bidirectional(link_flag);startPoint(Node_rel);endPoint(Node_rel);cut(OrgZone_max_imp);interaction(v_i,w_j,dist_logit(alpha,beta,gamma)):D_i'
					, convert(OrgToDest/LinkSet/impedance_LateEveningRush_min, s_f)
					, OrgToDest/LinkSet/F1
					, OrgToDest/LinkSet/F2
					, OrgToDest/LinkSet/isBidirectional
					, OrgToDest/nr_orgNode
					, OrgToDest/nr_destNode
					, convert(settings/max_traveldistance_min, s_f) 
					, 1f                                 // v_i
					, settings/dest_mass[float32]        // w_j
					, ModelParameters/Advanced/Distance_Decay/car_a , ModelParameters/Advanced/Distance_Decay/car_b , ModelParameters/Advanced/Distance_Decay/car_c
				);

			unit<uint64> MaxSpeed := 
				dijkstra_m64('bidirectional(link_flag);startPoint(Node_rel);endPoint(Node_rel);cut(OrgZone_max_imp);interaction(v_i,w_j,dist_logit(alpha,beta,gamma)):D_i'
					, convert(OrgToDest/LinkSet/impedance_max_car_min, s_f)
					, OrgToDest/LinkSet/F1
					, OrgToDest/LinkSet/F2
					, OrgToDest/LinkSet/isBidirectional
					, OrgToDest/nr_orgNode
					, OrgToDest/nr_destNode
					, convert(settings/max_traveldistance_min, s_f)
					, 1f                                 // v_i
					, settings/dest_mass[float32]        // w_j
					, ModelParameters/Advanced/Distance_Decay/car_a , ModelParameters/Advanced/Distance_Decay/car_b , ModelParameters/Advanced/Distance_Decay/car_c
				);
		}
		
		
		container ExportTable_Decayed
		{
			attribute<float32> nr_items_of_interest_decayed_MaxSpeed        (org) := Decayed/MaxSpeed/D_i;
			attribute<float32> nr_items_of_interest_decayed_MorningRush     (org) := Decayed/MorningRush/D_i;
			attribute<float32> nr_items_of_interest_decayed_NoonRush        (org) := Decayed/NoonRush/D_i;
			attribute<float32> nr_items_of_interest_decayed_LateEveningRush (org) := Decayed/LateEveningRush/D_i;
			attribute<float32> Loss_MorningRush       (org) := nr_items_of_interest_decayed_MaxSpeed - nr_items_of_interest_decayed_MorningRush;
			attribute<float32> Loss_NoonRush          (org) := nr_items_of_interest_decayed_MaxSpeed - nr_items_of_interest_decayed_NoonRush;
			attribute<float32> Loss_LateEveningRush   (org) := nr_items_of_interest_decayed_MaxSpeed - nr_items_of_interest_decayed_LateEveningRush;
			
			attribute<string> BodyLines (org) := org/name + ';' + string(nr_items_of_interest_decayed_MaxSpeed) + ';' + string(nr_items_of_interest_decayed_MorningRush)+';'+string(nr_items_of_interest_decayed_NoonRush)+';'+string(nr_items_of_interest_decayed_LateEveningRush);
			parameter<string> File            := 'Org;freeflow;MorningRush;NoonRush;LateEveningRush\n'++AsList(BodyLines, '\n'), StorageName = "=settings/fileNamePrefix+''+ModelParameters/items_of_interest+'_decayed'+settings/fileNameSuffix +'.csv'", StorageType = "str";
		}
		
		unit<uint64> ExportTable_Traveltimes := Traveltimes/MaxSpeed
		{
			attribute<org > Org_rel := OrgZone_rel;
			attribute<dest> Dst_rel := DstZone_rel;
			
			attribute<s_f> MaxSpeed_imp        := Impedance;
			attribute<s_f> MorningRush_imp     := rjoin(Org_Dest, Traveltimes/MorningRush/Org_Dest, Traveltimes/MorningRush/Impedance);
			attribute<s_f> NoonRush_imp        := rjoin(Org_Dest, Traveltimes/NoonRush/Org_Dest, Traveltimes/NoonRush/Impedance);
			attribute<s_f> LateEveningRush_imp := rjoin(Org_Dest, Traveltimes/LateEveningRush/Org_Dest, Traveltimes/LateEveningRush/Impedance);
			
			attribute<bool>  IsCorrect_MorningRush     := MorningRush_imp >= MaxSpeed_imp;
			attribute<bool>  IsCorrect_NoonRush        := NoonRush_imp >= MaxSpeed_imp;
			attribute<bool>  IsCorrect_LateEveningRush := LateEveningRush_imp >= MaxSpeed_imp;
			
			attribute<string> BodyLines :=
				org/name[Org_rel] + ';' + 
				dest/name[Dst_rel] + ';' +
				string(MaxSpeed_imp);
				// string(MaxSpeed_imp) + ';' + 
				///string(MorningRush_imp);
				// string(MorningRush_imp)+';' +
				// string(NoonRush_imp)+';' +
				// string(LateEveningRush_imp);
			// parameter<string> File := 'Org;Dst;MaxSpeed;MorningRush;NoonRush;LateEveningRush\n'++AsList(BodyLines, '\n'), StorageName = "=settings/fileNamePrefix+'Traveltimes'+settings/fileNameSuffix +'.csv'", StorageType = "str";
			parameter<string> File := 'Org;Dst;MaxSpeed\n'++AsList(BodyLines, '\n'), StorageName = "=settings/fileNamePrefix+'Traveltimes'+settings/fileNameSuffix +'.csv'", StorageType = "str";
		}
	}
	
	#include<StaticNetsCreator.dms>

	Template LoadCSVThroughGDAL 
	{
		unit<uint32> File_Structure;
		parameter<File_Structure> inFile;
		
		container CreateFSS
		{
			unit<uint32> ReadCSV
			: StorageName     = "= '%NetworkModel_dir%/Infrastructuur/GTFS/'+ModelParameters/GTFS_file_date+'/'+File_Structure/Name[inFile]+'.csv'"
			, StorageType     = "gdal.vect"
			, StorageReadOnly = "True";

			unit<uint32> CSV_attributes := SubItem_PropValues(ReadCSV,'name');
			
			container MakeFSSDomain : StorageName = "= '%NetworkModel_dir%/Infrastructuur/GTFS/'+ModelParameters/GTFS_file_date+'/fss/'+File_Structure/Name[inFile]+'_domain.fss'"
			{
				unit<uint32> domain := ReadCSV;
			}
	
			container MakeFSS := 
				for_each_nedv(
					CSV_attributes/name
					, 'ReadCSV/' + CSV_attributes/name
					, MakeFSSDomain/domain
					, string
				),	StorageName = "= '%NetworkModel_dir%/Infrastructuur/GTFS/'+ModelParameters/GTFS_file_date+'/fss/'+File_Structure/Name[inFile]+'.fss'"
			{
				unit<uint32> domain := MakeFSSDomain/domain;
			}
		}
	}
	
	Template doDateSelection 
	{
		container Data;
		unit<uint32> Services;
		
		unit<uint32> Calendar:= Data/Calendar/read_domain/domain
		{
			attribute<string> monday                  := Data/Calendar/data/monday;
			attribute<string> tuesday                 := Data/Calendar/data/tuesday;
			attribute<string> wednesday               := Data/Calendar/data/wednesday;
			attribute<string> thursday                := Data/Calendar/data/thursday;
			attribute<string> friday                  := Data/Calendar/data/friday;
			attribute<string> saturday                := Data/Calendar/data/saturday;
			attribute<string> sunday                  := Data/Calendar/data/sunday;
			attribute<string> service_id              := Data/Calendar/data/service_id;
			attribute<uint32> nStartDate              := uint32(Data/Calendar/data/start_date);
			attribute<uint32> nEndDate                := uint32(Data/Calendar/data/end_date);
			attribute<bool>   Today_in_daterange      := uint32(ModelParameters/Analysis_date) >= nStartDate && uint32(ModelParameters/Analysis_date) <= nEndDate;
			attribute<bool>   Yesterday_in_daterange  := uint32(ModelParameters/Advanced/PrevDate) >= nStartDate && uint32(ModelParameters/Advanced/PrevDate) <= nEndDate;
		}
		
		unit<uint32> Calendar_dates := Data/Calendar_dates/read_domain/domain  
		{
			attribute<uint32>   nDate       := uint32(Data/Calendar_dates/data/date);
			attribute<uint32>   nType       := uint32(Data/Calendar_dates/data/exception_type);
			attribute<Services> ServicesRef := rlookup(Data/Calendar_dates/data/service_id, Services/Values);
			attribute<uint32>   Today       := uint32(uint32(ModelParameters/Analysis_date) = nDate);  
			attribute<uint32>   Yesterday   := uint32(uint32(ModelParameters/Advanced/PrevDate) = nDate);
		}
	}

	unit<SPoint> Neighbourhood := range(spoint, point(int16(-1), int16(-1)), point(int16(2), int16(2))), Descr = "Rooks case contiguous neighbours (first order)"
	{
		attribute<uint32> Top     := uint32(id(.) = point(int16(0),int16(1),spoint));
		attribute<uint32> Right   := uint32(id(.) = point(int16(1),int16(0),spoint));
		attribute<uint32> Bottom  := uint32(id(.) = point(int16(0),int16(-1),spoint));
		attribute<uint32> Left    := uint32(id(.) = point(int16(-1),int16(0),spoint));
	}
	
	Template MakeNetwerkType_T
	{
		parameter<string> NetwerkType;
		
		unit<uint32> land_road := ='Subset(Read_Roads_NL_fss/IsPartOf'+NetwerkType+'Network)'
		,	DialogData  = "line"
		,	DialogType  = "Map"
		{
			attribute<geometries/rdc>                line (arc) := Read_Roads_NL_fss/geometry[nr_OrgEntity];
			attribute<classifications/OSM/wegtype>        wegtype    := Read_Roads_NL_fss/wegtype[nr_OrgEntity];
			attribute<int32>                         maxspeed   := Read_Roads_NL_fss/maxspeed[nr_OrgEntity];
			attribute<string>                        OSM_id     := Read_Roads_NL_fss/OSM_id[nr_OrgEntity];
			attribute<km_hr>                         congestion_speed_bike := Read_Roads_NL_fss/congestion_speed_bike[nr_OrgEntity];
			attribute<float32>                       congestion_speed_MorningRush := Read_Roads_NL_fss/congestion_speed_MorningRush[nr_OrgEntity];
			attribute<float32>                       congestion_flow_MorningRush  := Read_Roads_NL_fss/congestion_flow_MorningRush[nr_OrgEntity];
			attribute<float32>                       congestion_speed_NoonRush := Read_Roads_NL_fss/congestion_speed_NoonRush[nr_OrgEntity];
			attribute<float32>                       congestion_flow_NoonRush  := Read_Roads_NL_fss/congestion_flow_NoonRush[nr_OrgEntity];
			attribute<float32>                       congestion_speed_LateEveningRush := Read_Roads_NL_fss/congestion_speed_LateEveningRush[nr_OrgEntity];
			attribute<float32>                       congestion_flow_LateEveningRush  := Read_Roads_NL_fss/congestion_flow_LateEveningRush[nr_OrgEntity];
		}
		
		unit<uint32> ferry := ='Subset(boat/link/isPartOf'+NetwerkType+'Network)'
		,	DialogData  = "line"
		,	DialogType  = "Map"
		{
			attribute<geometries/rdc>                line (arc) := boat/link/line[nr_OrgEntity];
			attribute<classifications/OSM/wegtype>   wegtype    := boat/link/wegtype[nr_OrgEntity];
			attribute<int32>                         maxspeed   := const((0/0),.,int32);
			attribute<string>                        OSM_id     := const('',.);
		}
	
		unit<uint32> road := Union_Unit(land_road, ferry)
		,	DialogData  = "geometry"
		,	DialogType  = "Map"
		{
			attribute<geometries/rdc>                geometry (arc)   := Union_Data(road, land_road/line , ferry/line);
			attribute<classifications/OSM/wegtype>   wegtype          := Union_Data(road, land_road/wegtype, ferry/wegtype);
			attribute<int32>                         maxspeed         := Union_Data(road, land_road/maxspeed, ferry/maxspeed);
			attribute<string>                        OSM_id           := Union_Data(road, land_road/OSM_id, ferry/OSM_id);
			attribute<km_hr>                         congestion_speed_bike := Union_Data(road, land_road/congestion_speed_bike, const((0/0),ferry,km_hr));
			attribute<float32>                       congestion_speed_MorningRush := Union_Data(road, land_road/congestion_speed_MorningRush, const((0/0),ferry,float32));
			attribute<float32>                       congestion_flow_MorningRush  := Union_Data(road, land_road/congestion_flow_MorningRush, const((0/0),ferry,float32));
			attribute<float32>                       congestion_speed_NoonRush := Union_Data(road, land_road/congestion_speed_NoonRush, const((0/0),ferry,float32));
			attribute<float32>                       congestion_flow_NoonRush  := Union_Data(road, land_road/congestion_flow_NoonRush, const((0/0),ferry,float32));
			attribute<float32>                       congestion_speed_LateEveningRush := Union_Data(road, land_road/congestion_speed_LateEveningRush, const((0/0),ferry,float32));
			attribute<float32>                       congestion_flow_LateEveningRush  := Union_Data(road, land_road/congestion_flow_LateEveningRush, const((0/0),ferry,float32));
		}
		
		container preperation
		{
			unit<uint32> road_segments_not_unique  := arc2segm(road/geometry)
			,	DialogData  = "point"
			,	DialogType  = "Map"
			{
				attribute<geometries/rdc>               point;
				attribute<geometries/rdc>               nextpoint;
				attribute<string>                       key              := String(pointRow(point)) + '_' + String(pointCol(point)) + '_' + String(pointRow(nextpoint)) + '_'+ String(pointCol(nextpoint));
				attribute<road>                         SequenceNr;
				attribute<classifications/OSM/wegtype>  wegtype          := road/wegtype[SequenceNr];
				attribute<int32>                        maxspeed         := road/maxspeed[SequenceNr];
				attribute<string>                       OSM_id           := road/OSM_id[SequenceNr];
				attribute<km_hr>                        congestion_speed_bike := road/congestion_speed_bike[SequenceNr];
				attribute<float32>                      congestion_speed_MorningRush := road/congestion_speed_MorningRush[SequenceNr];
				attribute<float32>                      congestion_flow_MorningRush  := road/congestion_flow_MorningRush[SequenceNr];
				attribute<float32>                      congestion_speed_NoonRush := road/congestion_speed_NoonRush[SequenceNr];
				attribute<float32>                      congestion_flow_NoonRush  := road/congestion_flow_NoonRush[SequenceNr];
				attribute<float32>                      congestion_speed_LateEveningRush := road/congestion_speed_LateEveningRush[SequenceNr];
				attribute<float32>                      congestion_flow_LateEveningRush  := road/congestion_flow_LateEveningRush[SequenceNr];
			}
			// In de OSM komen bepaalde wegen en wegsegmenten dubbel voor, deze leiden tot problemen bij het bepalen van het type kruispunt
			// vandaar dat ze hier uit de selectie worden gehaald.
			
			unit <uint32> road_segments := unique(road_segments_not_unique/key)
			,	DialogData = "point"
			,	DialogType = "Map"
			{
				attribute<geometries/rdc>                point            := rjoin(values, road_segments_not_unique/key, road_segments_not_unique/point);
				attribute<geometries/rdc>                nextpoint        := rjoin(values, road_segments_not_unique/key, road_segments_not_unique/nextpoint);
				attribute<classifications/OSM/wegtype>   wegtype          := rjoin(values, road_segments_not_unique/key, road_segments_not_unique/wegtype);
				attribute<int32>                         maxspeed         := rjoin(values, road_segments_not_unique/key, road_segments_not_unique/maxspeed);
				attribute<string>                        OSM_id           := rjoin(values, road_segments_not_unique/key, road_segments_not_unique/OSM_id);
				attribute<km_hr>                         congestion_speed_bike := rjoin(values, road_segments_not_unique/key, road_segments_not_unique/congestion_speed_bike);
				attribute<float32>                       congestion_speed_MorningRush := rjoin(values, road_segments_not_unique/key, road_segments_not_unique/congestion_speed_MorningRush);
				attribute<float32>                       congestion_flow_MorningRush  := rjoin(values, road_segments_not_unique/key, road_segments_not_unique/congestion_flow_MorningRush);
				attribute<float32>                       congestion_speed_NoonRush := rjoin(values, road_segments_not_unique/key, road_segments_not_unique/congestion_speed_NoonRush);
				attribute<float32>                       congestion_flow_NoonRush  := rjoin(values, road_segments_not_unique/key, road_segments_not_unique/congestion_flow_NoonRush);
				attribute<float32>                       congestion_speed_LateEveningRush := rjoin(values, road_segments_not_unique/key, road_segments_not_unique/congestion_speed_LateEveningRush);
				attribute<float32>                       congestion_flow_LateEveningRush  := rjoin(values, road_segments_not_unique/key, road_segments_not_unique/congestion_flow_LateEveningRush);
	
				unit<uint32> pointset  := union_unit(road_segments, road_segments)
				{
					attribute<geometries/rdc>      point    := Union_Data(pointset, road_segments/point, road_segments/nextpoint);
					attribute<road_segments>       ArcID    := value(ID(pointset) % nrofrows(road_segments), road_segments);
					attribute<uint32>              VolgNr   := ID(pointset) / nrofrows(road_segments);
				}
				attribute<geometries/rdc> line(arc)  := points2sequence(pointset/point, pointset/ArcID, pointset/VolgNr);
			}
			
			unit<uint32> extra_links  := union_unit(ExtraVerbindingen/link, ExtraCarToAbroad/link)
			{
				attribute<geometries/rdc>                line (arc)  := union_data(., ExtraVerbindingen/link/line, ExtraCarToAbroad/link/line);
				attribute<classifications/OSM/wegtype>   wegtype     := union_data(., ExtraVerbindingen/link/wegtype, ExtraCarToAbroad/link/wegtype);
				attribute<int32>                         maxspeed    := union_data(., ExtraVerbindingen/link/maxspeed, ExtraCarToAbroad/link/maxspeed);
				attribute<string>                        OSM_id      := union_data(., const('',ExtraVerbindingen/link), const('',ExtraCarToAbroad/link));
				
			}
			
			
			unit<uint32> extra_nodes := union_unit(ExtraVerbindingen/nodes, ExtraCarToAbroad/nodes)
			{
				attribute<geometries/rdc> location  := union_data(., ExtraVerbindingen/nodes/UnionData, ExtraCarToAbroad/nodes/UnionData);
			}
			unit<uint32> road_segments_with_extra_nodes := connect(road_segments/line, extra_nodes/location)
			{
				attribute<geometries/rdc>               UnionData (arc);
				attribute<string>                       OSM_id           := road_segments/OSM_id[nr_OrgEntity];
				attribute<classifications/OSM/wegtype>  wegtype          := MakeDefined(road_segments/wegtype[nr_OrgEntity], value(69,classifications/OSM/wegtype));
				attribute<int32>                        maxspeed         := road_segments/maxspeed[nr_OrgEntity];
				attribute<km_hr>                        congestion_speed_bike        := road_segments/congestion_speed_bike[nr_OrgEntity];
				attribute<float32>                      congestion_speed_MorningRush := road_segments/congestion_speed_MorningRush[nr_OrgEntity];
				attribute<float32>                      congestion_flow_MorningRush  := road_segments/congestion_flow_MorningRush[nr_OrgEntity];
				attribute<float32>                      congestion_speed_NoonRush := road_segments/congestion_speed_NoonRush[nr_OrgEntity];
				attribute<float32>                      congestion_flow_NoonRush  := road_segments/congestion_flow_NoonRush[nr_OrgEntity];
				attribute<float32>                      congestion_speed_LateEveningRush := road_segments/congestion_speed_LateEveningRush[nr_OrgEntity];
				attribute<float32>                      congestion_flow_LateEveningRush  := road_segments/congestion_flow_LateEveningRush[nr_OrgEntity];
			}

		}
		
		unit <uint32> Make_FSS  := ='union_unit(preperation/road_segments_with_extra_nodes, preperation/extra_links, Abroad/Main_RegionsCombined/'+NetwerkType+')'
		,	DialogData  = "line"
		,	DialogType  = "Map"
		,	StorageName = "= '%LocalDataDir%/NetworkModel/OSM/'+NetwerkType+'_network_'+file_date+'.fss'"
		{
			attribute<geometries/rdc>               line (arc)       := ='union_data(., preperation/road_segments_with_extra_nodes/UnionData, preperation/extra_links/line,    Abroad/Main_RegionsCombined/'+NetwerkType+'/line)';
			attribute<classifications/OSM/wegtype>  wegtype          := ='union_data(., preperation/road_segments_with_extra_nodes/wegtype,   preperation/extra_links/wegtype, Abroad/Main_RegionsCombined/'+NetwerkType+'/wegtype)';
			attribute<int32>                        maxspeed_src     := ='union_data(., preperation/road_segments_with_extra_nodes/maxspeed,   preperation/extra_links/maxspeed, Abroad/Main_RegionsCombined/'+NetwerkType+'/maxspeed)';
			attribute<int32>                        maxspeed         := maxspeed_src == 0i ? (0/0)[int32] : maxspeed_src;
			attribute<km_hr>                        congestion_speed_bike := ='union_data(., preperation/road_segments_with_extra_nodes/congestion_speed_bike,  const((0/0), preperation/extra_links, km_hr),  const((0/0), Abroad/Main_RegionsCombined/'+NetwerkType+', km_hr))';
			attribute<float32>                      congestion_speed_MorningRush := ='union_data(., preperation/road_segments_with_extra_nodes/congestion_speed_MorningRush,  const((0/0), preperation/extra_links, float32),  const((0/0), Abroad/Main_RegionsCombined/'+NetwerkType+', float32))';
			attribute<float32>                      congestion_flow_MorningRush  := ='union_data(., preperation/road_segments_with_extra_nodes/congestion_flow_MorningRush ,  const((0/0), preperation/extra_links, float32),  const((0/0), Abroad/Main_RegionsCombined/'+NetwerkType+', float32))';
			attribute<float32>                      congestion_speed_NoonRush    := ='union_data(., preperation/road_segments_with_extra_nodes/congestion_speed_NoonRush,  const((0/0), preperation/extra_links, float32),  const((0/0), Abroad/Main_RegionsCombined/'+NetwerkType+', float32))';
			attribute<float32>                      congestion_flow_NoonRush     := ='union_data(., preperation/road_segments_with_extra_nodes/congestion_flow_NoonRush ,  const((0/0), preperation/extra_links, float32),  const((0/0), Abroad/Main_RegionsCombined/'+NetwerkType+', float32))';
			attribute<float32>                      congestion_speed_LateEveningRush    := ='union_data(., preperation/road_segments_with_extra_nodes/congestion_speed_LateEveningRush,  const((0/0), preperation/extra_links, float32),  const((0/0), Abroad/Main_RegionsCombined/'+NetwerkType+', float32))';
			attribute<float32>                      congestion_flow_LateEveningRush     := ='union_data(., preperation/road_segments_with_extra_nodes/congestion_flow_LateEveningRush ,  const((0/0), preperation/extra_links, float32),  const((0/0), Abroad/Main_RegionsCombined/'+NetwerkType+', float32))';
			attribute<.>                            id               := id(.);
			attribute<string>                       wegtype_label    := /classifications/OSM/wegtype/Label[wegtype];
			attribute<string>                       OSM_id           := ='union_data(., preperation/road_segments_with_extra_nodes/OSM_id, preperation/extra_links/OSM_id,    Abroad/Main_RegionsCombined/'+NetwerkType+'/OSM_id)';
		}
		
		unit<uint32> Attributes := Subtree_PropValues(Make_all, 'name');

		unit<uint32> Read_FSS 
		:	DialogData  = "line"
		,	DialogType  = "Map"
		,	StorageName = "= '%LocalDataDir%/NetworkModel/OSM/'+NetwerkType+'_network_'+file_date+'.fss'"
		,	StorageReadOnly = "true"
		{
			attribute<geometries/rdc>               line (arc);
			attribute<classifications/OSM/wegtype>  wegtype;
			attribute<string>                       OSM_id;
			attribute<string>                       wegtype_label;
			attribute<int32>                        maxspeed;
			attribute<float32>                      length := arc_length(line, float32);
			attribute<km_hr>                        freeflow_speed_bike   := const(ModelParameters/Advanced/BikingSpeed_kmhr,.);
			attribute<km_hr>                        congestion_speed_bike;
			attribute<km_hr>                        congestion_speed_MorningRush;
			attribute<float32>                      congestion_flow_MorningRush;
			attribute<km_hr>                        congestion_speed_NoonRush;
			attribute<float32>                      congestion_flow_NoonRush;
			attribute<km_hr>                        congestion_speed_LateEveningRush;
			attribute<float32>                      congestion_flow_LateEveningRush;
		}
	}
}